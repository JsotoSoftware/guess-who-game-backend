<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guess Who Game - Test Client</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            color: #4CAF50;
            margin-bottom: 20px;
        }
        .section {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #3a3a3a;
        }
        .section h2 {
            color: #64B5F6;
            margin-bottom: 15px;
            font-size: 1.2em;
        }
        .row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .col {
            flex: 1;
            min-width: 200px;
        }
        input, select, button {
            width: 100%;
            padding: 10px;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            background: #1a1a1a;
            color: #e0e0e0;
            font-size: 14px;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }
        button:hover:not(:disabled) {
            background: #45a049;
        }
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        button.danger {
            background: #f44336;
        }
        button.danger:hover:not(:disabled) {
            background: #da190b;
        }
        button.warning {
            background: #ff9800;
        }
        button.warning:hover:not(:disabled) {
            background: #e68900;
        }
        .status {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-weight: bold;
        }
        .status.connected {
            background: #4CAF50;
            color: white;
        }
        .status.disconnected {
            background: #f44336;
            color: white;
        }
        .status.connecting {
            background: #ff9800;
            color: white;
        }
        .log {
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            padding: 15px;
            height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .log-entry {
            margin-bottom: 5px;
            padding: 3px 0;
        }
        .log-entry.sent {
            color: #64B5F6;
        }
        .log-entry.received {
            color: #81C784;
        }
        .log-entry.error {
            color: #e57373;
        }
        .log-entry.info {
            color: #FFB74D;
        }
        .info-box {
            background: #1e3a5f;
            border-left: 4px solid #2196F3;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 4px;
        }
        .test-section {
            background: #2a2a2a;
            padding: 15px;
            margin-top: 15px;
            border-radius: 4px;
            border: 1px solid #3a3a3a;
        }
        .test-section h3 {
            color: #FFB74D;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ® Guess Who Game - Test Client</h1>

        <!-- Configuration -->
        <div class="section">
            <h2>Configuration</h2>
            <div class="row">
                <div class="col">
                    <label>API Base URL:</label>
                    <input type="text" id="apiUrl" value="http://localhost:8080" placeholder="http://localhost:8080">
                </div>
                <div class="col">
                    <label>Display Name:</label>
                    <input type="text" id="displayName" value="TestUser" placeholder="Your display name">
                </div>
                <div class="col">
                    <label>Role:</label>
                    <select id="role">
                        <option value="player">Player</option>
                        <option value="host">Host</option>
                    </select>
                </div>
            </div>
            <div class="row">
                <div class="col">
                    <button id="authBtn" onclick="authenticate()">1. Authenticate (Guest)</button>
                </div>
                <div class="col">
                    <button id="connectBtn" onclick="connectWS()" disabled>2. Connect WebSocket</button>
                </div>
                <div class="col">
                    <button id="disconnectBtn" onclick="disconnectWS()" disabled class="danger">Disconnect</button>
                </div>
            </div>
            <div id="authStatus" class="status disconnected">Not Authenticated</div>
            <div id="wsStatus" class="status disconnected">Disconnected</div>
        </div>

        <!-- Room Management -->
        <div class="section">
            <h2>Room Management</h2>
            <div class="row">
                <div class="col">
                    <label>Room Code:</label>
                    <input type="text" id="roomCode" placeholder="Enter room code or create new">
                </div>
                <div class="col">
                    <button onclick="createRoom()" id="createRoomBtn" disabled>Create Room</button>
                </div>
                <div class="col">
                    <button onclick="joinRoom()" id="joinRoomBtn" disabled>Join Room (WS)</button>
                </div>
            </div>
            <div class="row">
                <div class="col">
                    <button onclick="getRoomState()" id="getStateBtn" disabled>Get Room State (HTTP)</button>
                </div>
                <div class="col">
                    <button onclick="getRoomMembers()" id="getMembersBtn" disabled>Get Members (HTTP)</button>
                </div>
            </div>
        </div>

        <!-- WebSocket Messages -->
        <div class="section">
            <h2>WebSocket Messages</h2>
            <div class="row">
                <div class="col">
                    <label>Message Type:</label>
                    <select id="msgType">
                        <option value="client:ping">client:ping</option>
                        <option value="host:start_round">host:start_round</option>
                        <option value="host:score_add">host:score_add</option>
                        <option value="host:end_round">host:end_round</option>
                    </select>
                </div>
                <div class="col">
                    <label>Payload (JSON):</label>
                    <input type="text" id="msgPayload" placeholder='{"code":"ABC123","lang":"es"}' value='{"code":"","lang":"es"}'>
                </div>
                <div class="col">
                    <label>Request ID (optional, echoed in acks/errors):</label>
                    <input type="text" id="requestId" placeholder="e.g. req-1">
                </div>
                <div class="col">
                    <button onclick="sendMessage()" id="sendBtn" disabled>Send Message</button>
                </div>
            </div>
            <div class="row" style="margin-top: 10px;">
                <div class="col">
                    <button onclick="testConnection()" id="testConnBtn" disabled class="warning" style="width: auto;">Test Connection (Send Ping)</button>
                </div>
            </div>
        </div>

        <!-- Tests -->
        <div class="section">
            <h2>ðŸ§ª Tests</h2>

            <h3 style="color:#81C784;margin-top:0;">DB / StartRoundAssignCharacters</h3>

            <div class="test-section">
                <h3>No repeats across rounds</h3>
                <p>Run 2 rounds, collect character IDs from <code>round:assigned</code>; assert round 2 IDs are not in round 1.</p>
                <div class="info-box">Join as <strong>host</strong> in a room with 2+ connected (e.g. host + player in another tab). Room must have packs with enough characters for 2 rounds.</div>
                <button onclick="testNoRepeatsAcrossRounds()" id="testNoRepeatsBtn" disabled>Run</button>
            </div>

            <div class="test-section">
                <h3>Not enough characters</h3>
                <p>Send <code>host:start_round</code> when the room has fewer available characters than players; expect error &quot;not enough characters&quot;.</p>
                <div class="info-box">Setup: room whose selected packs have &lt; N available characters, and N players connected. If the error is not &quot;not enough characters&quot;, the precondition was not met.</div>
                <button onclick="testNotEnoughCharacters()" id="testNotEnoughBtn" disabled>Run</button>
            </div>

            <div class="test-section">
                <h3>Concurrent start_round (no duplicate characters)</h3>
                <p>Send two <code>host:start_round</code> back-to-back. Expect one <code>host:round_started</code> and one error &quot;current round must be ended&quot;; no duplicate character assignments.</p>
                <div class="info-box">Join as <strong>host</strong>. Test sends 2x start_round, then end_round to clean up.</div>
                <button onclick="testConcurrentStartRound()" id="testConcurrentBtn" disabled>Run</button>
            </div>

            <h3 style="color:#81C784;margin-top:20px;">WS handler (table-driven)</h3>

            <div class="test-section">
                <h3>Join invalid payload</h3>
                <p>Send <code>room:join</code> with invalid payloads; expect <code>error</code> with &quot;invalid join payload&quot;.</p>
                <div class="info-box">Connected (join not required). Cases: <code>{}</code>, <code>{code:&quot;A&quot;}</code>, <code>{code:&quot;A&quot;,displayName:&quot;X&quot;}</code>, <code>{code:&quot;A&quot;,displayName:&quot;X&quot;,role:&quot;x&quot;}</code>.</div>
                <button onclick="testJoinInvalidPayload()" id="testJoinInvalidBtn" disabled>Run</button>
            </div>

            <div class="test-section">
                <h3>Host permission enforcement</h3>
                <p>As <strong>player</strong>, send <code>host:start_round</code>, <code>host:score_add</code>, <code>host:end_round</code>; expect &quot;host only&quot; for each.</p>
                <div class="info-box">Create room in another tab as host, join there. In this tab join the same room as <strong>player</strong>, then run.</div>
                <button onclick="testHostPermissionEnforcement()" id="testHostPermBtn" disabled>Run</button>
            </div>

            <div class="test-section">
                <h3>Score update path updates presence</h3>
                <p>As host, <code>host:score_add</code> for a member; expect <code>host:score_added</code> and <code>room:presence</code> with updated score.</p>
                <div class="info-box">Join as <strong>host</strong>. Test scores yourself. For a clear pass, start from a fresh join (score 0).</div>
                <button onclick="testScoreUpdatePresence()" id="testScorePresenceBtn" disabled>Run</button>
            </div>
        </div>

        <!-- Message Log -->
        <div class="section">
            <h2>Message Log</h2>
            <button onclick="clearLog()" class="warning" style="width: auto; margin-bottom: 10px;">Clear Log</button>
            <div id="log" class="log"></div>
        </div>
    </div>

    <script>
        let accessToken = null;
        let ws = null;
        let pingInterval = null;
        let uiSyncInterval = null;
        let currentRoomCode = null;
        let currentUserId = null;

        const API_URL = () => document.getElementById('apiUrl').value;

        function log(message, type = 'info') {
            const logEl = document.getElementById('log');
            if (!logEl) {
                console.error('Log element not found!');
                return;
            }
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
            // Also log to console
            console.log(`[${type}] ${message}`);
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }

        function updateStatus(elementId, status, text) {
            const el = document.getElementById(elementId);
            el.className = `status ${status}`;
            el.textContent = text;
        }

        function syncUiState() {
            const wsOpen = !!(ws && ws.readyState === WebSocket.OPEN);

            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            const joinRoomBtn = document.getElementById('joinRoomBtn');
            const sendBtn = document.getElementById('sendBtn');
            const testConnBtn = document.getElementById('testConnBtn');

            if (connectBtn) connectBtn.disabled = !accessToken || wsOpen;
            if (disconnectBtn) disconnectBtn.disabled = !wsOpen;
            if (joinRoomBtn) joinRoomBtn.disabled = !wsOpen;
            if (sendBtn) sendBtn.disabled = !wsOpen;
            if (testConnBtn) testConnBtn.disabled = !wsOpen;
        }

        async function authenticate() {
            try {
                log('Authenticating as guest...', 'info');
                const response = await fetch(`${API_URL()}/v1/auth/guest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (!response.ok) {
                    throw new Error(`Auth failed: ${response.statusText}`);
                }
                
                const data = await response.json();
                accessToken = data.accessToken;
                updateStatus('authStatus', 'connected', 'Authenticated');
                document.getElementById('authBtn').disabled = true;
                document.getElementById('connectBtn').disabled = false;
                document.getElementById('createRoomBtn').disabled = false;
                document.getElementById('getStateBtn').disabled = false;
                document.getElementById('getMembersBtn').disabled = false;
                log(`âœ“ Authenticated. Token (${accessToken}) expires at: ${new Date(data.expiresAt).toLocaleString()}`, 'info');
                syncUiState();
            } catch (error) {
                log(`âœ— Auth error: ${error.message}`, 'error');
                updateStatus('authStatus', 'disconnected', 'Auth Failed');
            }
        }

        function connectWS() {
            if (!accessToken) {
                log('Please authenticate first', 'error');
                return;
            }

            const wsUrl = API_URL().replace('http://', 'ws://').replace('https://', 'wss://');
            const url = `${wsUrl}/ws?access_token=${accessToken}`;
            
            log(`Connecting to ${url}...`, 'info');
            updateStatus('wsStatus', 'connecting', 'Connecting...');
            
            ws = new WebSocket(url);

            ws.onopen = () => {
                log('âœ“ WebSocket connected', 'info');
                console.log('WebSocket opened, readyState:', ws.readyState);
                updateStatus('wsStatus', 'connected', 'Connected');
                syncUiState();
                ['testNoRepeatsBtn','testNotEnoughBtn','testConcurrentBtn','testJoinInvalidBtn','testHostPermBtn','testScorePresenceBtn'].forEach(id => {
                    const el = document.getElementById(id); if (el) el.disabled = false;
                });
                // Start ping interval
                startPing();
            };

            ws.onmessage = (event) => {
                // Debug: log to console as well
                console.log('WebSocket message received:', event.data);
                
                try {
                    const msg = JSON.parse(event.data);
                    // Format message nicely for display
                    const formatted = JSON.stringify(msg, null, 2);
                    log(`â† Received [${msg.type || 'unknown'}]:\n${formatted}`, 'received');
                    
                    // Also log to console for debugging
                    console.log('Parsed message:', msg);
                    
                    if (msg.type === 'room:joined') {
                        currentRoomCode = msg.payload?.code;
                        currentUserId = msg.payload?.userId || null;
                        if (currentRoomCode) {
                            document.getElementById('roomCode').value = currentRoomCode;
                        }
                    }
                    if (window.__testResolveNextMsg) {
                        try { window.__testResolveNextMsg(msg); } finally { window.__testResolveNextMsg = null; }
                    }
                    if (window.__testCollecting) {
                        (window.__testCollected = window.__testCollected || []).push(msg);
                    }
                    
                    // Show success/error messages prominently
                    if (msg.type === 'error') {
                        log(`âš ï¸ ERROR: ${msg.payload?.message || 'Unknown error'}${msg.requestId ? ' [requestId: ' + msg.requestId + ']' : ''}`, 'error');
                        console.error('WebSocket error:', msg.payload?.message);
                    } else if (msg.type === 'host:round_started') {
                        log(`âœ“ Round started successfully! Round ID: ${msg.payload?.roundId}, Players: ${msg.payload?.playerCount}${msg.requestId ? ' [requestId: ' + msg.requestId + ']' : ''}`, 'info');
                        console.log('Round started:', msg.payload);
                    } else if (msg.type === 'host:round_ended') {
                        log(`âœ“ Round ended successfully!${msg.requestId ? ' [requestId: ' + msg.requestId + ']' : ''}`, 'info');
                        console.log('Round ended', msg.requestId ? { requestId: msg.requestId } : {});
                    } else if (msg.type === 'host:score_added') {
                        log(`âœ“ Score added! userId=${msg.payload?.userId} delta=${msg.payload?.delta}${msg.requestId ? ' [requestId: ' + msg.requestId + ']' : ''}`, 'info');
                    } else if (msg.type === 'round:assigned') {
                        log(`âœ“ Received character assignments for round ${msg.payload?.roundId}`, 'info');
                        console.log('Round assigned:', msg.payload);
                    } else if (msg.type === 'server:pong') {
                        log(`âœ“ Pong received`, 'info');
                    } else if (msg.type === 'room:presence') {
                        log(`âœ“ Presence update received`, 'info');
                    }
                } catch (e) {
                    log(`â† Received (raw): ${event.data}`, 'received');
                    console.error('Failed to parse message:', e, event.data);
                }
            };

            ws.onerror = (error) => {
                log(`âœ— WebSocket error: ${error}`, 'error');
                console.error('WebSocket error:', error);
                updateStatus('wsStatus', 'disconnected', 'Error');
                syncUiState();
            };

            ws.onclose = (event) => {
                log(`âœ— WebSocket disconnected (code: ${event.code}, reason: ${event.reason || 'none'})`, 'info');
                console.log('WebSocket closed:', event.code, event.reason, event.wasClean);
                updateStatus('wsStatus', 'disconnected', 'Disconnected');
                syncUiState();
                stopPing();
            };
        }

        function disconnectWS() {
            if (ws) {
                ws.close();
                ws = null;
            }
        }

        function startPing() {
            if (pingInterval) clearInterval(pingInterval);
            pingInterval = setInterval(() => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    sendWSMessage({ type: 'client:ping' });
                }
            }, 10000); // Ping every 10 seconds
        }

        function stopPing() {
            if (pingInterval) {
                clearInterval(pingInterval);
                pingInterval = null;
            }
        }

        function sendWSMessage(message) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                log('WebSocket not connected', 'error');
                console.error('Cannot send: WebSocket not connected. State:', ws ? ws.readyState : 'null');
                return;
            }
            const json = JSON.stringify(message);
            ws.send(json);
            log(`â†’ Sent: ${json}`, 'sent');
            console.log('WebSocket sent:', json);
        }

        async function createRoom() {
            if (!accessToken) {
                log('Please authenticate first', 'error');
                return;
            }
            try {
                log('Creating room...', 'info');
                const response = await fetch(`${API_URL()}/v1/rooms`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${accessToken}`
                    }
                });
                if (!response.ok) throw new Error(`Failed: ${response.statusText}`);
                const data = await response.json();
                document.getElementById('roomCode').value = data.code;
                currentRoomCode = data.code;
                log(`âœ“ Room created: ${data.code}`, 'info');
            } catch (error) {
                log(`âœ— Create room error: ${error.message}`, 'error');
            }
        }

        function joinRoom() {
            const code = document.getElementById('roomCode').value;
            const displayName = document.getElementById('displayName').value;
            const role = document.getElementById('role').value;
            
            if (!code || !displayName) {
                log('Please enter room code and display name', 'error');
                return;
            }
            
            sendWSMessage({
                type: 'room:join',
                payload: {
                    code: code,
                    displayName: displayName,
                    role: role
                }
            });
        }

        function testConnection() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                log('WebSocket not connected. State: ' + (ws ? ws.readyState : 'null'), 'error');
                return;
            }
            log('Testing connection by sending ping...', 'info');
            sendWSMessage({ type: 'client:ping' });
        }

        function sendMessage() {
            const type = document.getElementById('msgType').value;
            let payload = {};
            
            try {
                const payloadStr = document.getElementById('msgPayload').value;
                if (payloadStr) {
                    payload = JSON.parse(payloadStr);
                }
                
                // Auto-fill room code if available (host:end_round ignores payload; harmless)
                if (currentRoomCode && !payload.code) {
                    payload.code = currentRoomCode;
                    document.getElementById('msgPayload').value = JSON.stringify(payload);
                }
            } catch (e) {
                log(`Invalid JSON payload: ${e.message}`, 'error');
                return;
            }
            
            const reqId = document.getElementById('requestId')?.value?.trim();
            const msg = { type, payload };
            if (reqId) msg.requestId = reqId;
            log(`Sending message: ${type}${reqId ? ' (requestId: ' + reqId + ')' : ''}`, 'info');
            sendWSMessage(msg);
        }

        async function getRoomState() {
            const code = document.getElementById('roomCode').value || currentRoomCode;
            if (!code) {
                log('Please enter room code', 'error');
                return;
            }
            if (!accessToken) {
                log('Please authenticate first', 'error');
                return;
            }
            
            try {
                log(`Fetching room state for ${code}...`, 'info');
                const response = await fetch(`${API_URL()}/v1/rooms/state?code=${code}`, {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });
                if (!response.ok) throw new Error(`Failed: ${response.statusText}`);
                const data = await response.json();
                log(`âœ“ Room State: ${JSON.stringify(data, null, 2)}`, 'info');
                log(`  â†’ current_round_id: ${data.current_round_id == null ? 'null' : JSON.stringify(data.current_round_id)}, round_status: ${data.round_status ?? '(missing)'}`, 'info');
            } catch (error) {
                log(`âœ— Get state error: ${error.message}`, 'error');
            }
        }

        async function getRoomMembers() {
            const code = document.getElementById('roomCode').value || currentRoomCode;
            if (!code) {
                log('Please enter room code', 'error');
                return;
            }
            if (!accessToken) {
                log('Please authenticate first', 'error');
                return;
            }
            
            try {
                log(`Fetching members for ${code}...`, 'info');
                const response = await fetch(`${API_URL()}/v1/rooms/members?code=${code}`, {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });
                if (!response.ok) throw new Error(`Failed: ${response.statusText}`);
                const data = await response.json();
                log(`âœ“ Members: ${JSON.stringify(data, null, 2)}`, 'info');
            } catch (error) {
                log(`âœ— Get members error: ${error.message}`, 'error');
            }
        }

        function waitForNextMessage(predicate) {
            predicate = predicate || (() => true);
            return new Promise(resolve => {
                window.__testResolveNextMsg = (m) => { if (predicate(m)) resolve(m); };
            });
        }

        function extractCharacterIdsFromCollected(collected) {
            const ids = [];
            for (const m of collected) {
                if (m.type === 'round:assigned' && m.payload && Array.isArray(m.payload.assignments)) {
                    for (const a of m.payload.assignments)
                        if (a.character && a.character.id) ids.push(a.character.id);
                }
            }
            return ids;
        }

        // --- DB / StartRoundAssignCharacters ---
        async function testNoRepeatsAcrossRounds() {
            const code = document.getElementById('roomCode').value || currentRoomCode;
            if (!code) { log('Join a room first', 'error'); return; }
            if (!ws || ws.readyState !== WebSocket.OPEN) { log('WebSocket not connected', 'error'); return; }

            log('ðŸ§ª No repeats across rounds', 'info');
            window.__testCollecting = true; window.__testCollected = [];
            sendWSMessage({ type: 'host:start_round', payload: { code, lang: 'es' } });
            await new Promise(r => setTimeout(r, 1800));
            const round1 = extractCharacterIdsFromCollected(window.__testCollected);
            window.__testCollected = [];

            sendWSMessage({ type: 'host:end_round', payload: {} });
            await new Promise(r => setTimeout(r, 400));
            sendWSMessage({ type: 'host:start_round', payload: { code, lang: 'es' } });
            await new Promise(r => setTimeout(r, 1800));
            const round2 = extractCharacterIdsFromCollected(window.__testCollected);
            window.__testCollecting = false;

            sendWSMessage({ type: 'host:end_round', payload: {} });
            const overlap = round2.some(id => round1.includes(id));
            if (overlap) {
                log(`âœ— FAIL: round 2 char IDs [${round2.join(',')}] overlap round 1 [${round1.join(',')}]`, 'error');
            } else {
                log(`âœ“ PASS: no repeats. Round1: ${round1.length} ids, Round2: ${round2.length} ids.`, 'info');
            }
        }

        async function testNotEnoughCharacters() {
            const code = document.getElementById('roomCode').value || currentRoomCode;
            if (!code) { log('Join a room first', 'error'); return; }
            if (!ws || ws.readyState !== WebSocket.OPEN) { log('WebSocket not connected', 'error'); return; }

            log('ðŸ§ª Not enough characters', 'info');
            window.__testResolveNextMsg = null;
            sendWSMessage({ type: 'host:start_round', payload: { code, lang: 'es' } });
            const m = await Promise.race([
                new Promise(r => { window.__testResolveNextMsg = (msg) => { window.__testResolveNextMsg = null; r(msg); }; }),
                new Promise(r => setTimeout(() => r({ type: 'timeout' }), 3000))
            ]);
            const err = (m.payload && m.payload.message) || '';
            if (err.toLowerCase().includes('not enough')) {
                log('âœ“ PASS: got "not enough characters" error.', 'info');
            } else if (m.type === 'host:round_started' || m.type === 'round:assigned') {
                sendWSMessage({ type: 'host:end_round', payload: {} });
                log('Precondition not met: room had enough characters. Use a room with very few available chars and 2+ players.', 'info');
            } else {
                log(`? Got: ${m.type} ${err}`, 'info');
            }
        }

        async function testConcurrentStartRound() {
            const code = document.getElementById('roomCode').value || currentRoomCode;
            if (!code) { log('Join a room first', 'error'); return; }
            if (!ws || ws.readyState !== WebSocket.OPEN) { log('WebSocket not connected', 'error'); return; }

            log('ðŸ§ª Concurrent start_round', 'info');
            window.__testCollecting = true; window.__testCollected = [];
            sendWSMessage({ type: 'host:start_round', payload: { code, lang: 'es' } });
            sendWSMessage({ type: 'host:start_round', payload: { code, lang: 'es' } });
            await new Promise(r => setTimeout(r, 2000));
            window.__testCollecting = false;
            const arr = window.__testCollected || [];
            const hasRoundStarted = arr.some(m => m.type === 'host:round_started');
            const errMsg = arr.find(m => m.type === 'error')?.payload?.message || '';
            const hasExpectedError = /current round must be ended|ended before starting/i.test(errMsg);
            sendWSMessage({ type: 'host:end_round', payload: {} });
            if (hasRoundStarted && hasExpectedError) {
                log('âœ“ PASS: one host:round_started, one "current round must be ended" error.', 'info');
            } else {
                log(`âœ— FAIL: hasRoundStarted=${hasRoundStarted} hasExpectedError=${hasExpectedError} (${errMsg})`, 'error');
            }
        }

        // --- WS handler (table-driven) ---
        async function testJoinInvalidPayload() {
            if (!ws || ws.readyState !== WebSocket.OPEN) { log('WebSocket not connected', 'error'); return; }

            const cases = [
                { payload: {}, expect: 'invalid' },
                { payload: { code: 'A' }, expect: 'invalid' },
                { payload: { code: 'A', displayName: 'X' }, expect: 'invalid' },
                { payload: { code: 'A', displayName: 'X', role: 'x' }, expect: 'invalid' }
            ];
            log('ðŸ§ª Join invalid payload (table-driven)', 'info');
            for (const c of cases) {
                window.__testResolveNextMsg = null;
                sendWSMessage({ type: 'room:join', payload: c.payload });
                const m = await Promise.race([
                    new Promise(r => { window.__testResolveNextMsg = (msg) => { window.__testResolveNextMsg = null; r(msg); }; }),
                    new Promise(r => setTimeout(() => r({ type: 'timeout' }), 2000))
                ]);
                const msg = (m.payload && m.payload.message) || '';
                const ok = m.type === 'error' && msg.toLowerCase().includes(c.expect);
                log(ok ? `  âœ“ ${JSON.stringify(c.payload)} -> error (${msg.slice(0,40)}...)` : `  âœ— ${JSON.stringify(c.payload)} -> ${m.type} ${msg}`, ok ? 'info' : 'error');
            }
            log('Done.', 'info');
        }

        async function testHostPermissionEnforcement() {
            if (!ws || ws.readyState !== WebSocket.OPEN) { log('WebSocket not connected', 'error'); return; }
            const code = document.getElementById('roomCode').value || currentRoomCode;
            if (!code) { log('Join as player first', 'error'); return; }

            const actions = [
                { type: 'host:start_round', payload: { code, lang: 'es' } },
                { type: 'host:score_add', payload: { userId: '00000000-0000-0000-0000-000000000000', delta: 1 } },
                { type: 'host:end_round', payload: {} }
            ];
            log('ðŸ§ª Host permission enforcement', 'info');
            for (const a of actions) {
                window.__testResolveNextMsg = null;
                sendWSMessage({ type: a.type, payload: a.payload });
                const m = await Promise.race([
                    new Promise(r => { window.__testResolveNextMsg = (msg) => { window.__testResolveNextMsg = null; r(msg); }; }),
                    new Promise(r => setTimeout(() => r({ type: 'timeout' }), 2000))
                ]);
                const ok = m.type === 'error' && (m.payload?.message || '').toLowerCase().includes('host only');
                log(ok ? `  âœ“ ${a.type} -> "host only"` : `  âœ— ${a.type} -> ${m.type}`, ok ? 'info' : 'error');
            }
            log('Done.', 'info');
        }

        async function testScoreUpdatePresence() {
            if (!ws || ws.readyState !== WebSocket.OPEN) { log('WebSocket not connected', 'error'); return; }
            const code = document.getElementById('roomCode').value || currentRoomCode;
            if (!code || !currentUserId) { log('Join as host first (need userId from room:joined)', 'error'); return; }

            log('ðŸ§ª Score update path updates presence', 'info');
            window.__testCollecting = true; window.__testCollected = [];
            sendWSMessage({ type: 'host:score_add', payload: { code, userId: currentUserId, delta: 5 } });
            await new Promise(r => setTimeout(r, 1500));
            window.__testCollecting = false;
            const arr = window.__testCollected || [];
            const hasScoreAdded = arr.some(m => m.type === 'host:score_added');
            const presence = arr.find(m => m.type === 'room:presence');
            const me = presence && presence.payload && (presence.payload.members || []).find(x => x.userId === currentUserId);
            const scoreOk = me && me.score === 5;
            if (hasScoreAdded && scoreOk) {
                log('âœ“ PASS: host:score_added and room:presence with score=5.', 'info');
            } else {
                log(`âœ— FAIL: hasScoreAdded=${hasScoreAdded} presenceScore=${me ? me.score : 'n/a'}`, 'error');
            }
        }

        // Auto-authenticate on load
        window.addEventListener('load', () => {
            log('Test client loaded. Click "Authenticate" to begin.', 'info');
            // Prevent UI buttons getting stuck disabled/enabled.
            uiSyncInterval = setInterval(syncUiState, 500);
            syncUiState();
        });
    </script>
</body>
</html>
